# -*- coding: utf-8 -*-
"""759Finalnew.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/188JwqY3lz2w9Zg_np2wd-8aQCXbk1bS6
"""

import os
import argparse

parser = argparse.ArgumentParser();
parser.add_argument('-l', type=int);
parser.add_argument('-a', type=int);
parser.add_argument('-g', type=str);
args = parser.parse_args();
print("Argument values:");
print(args.l);
print(args.a);
print(args.g);

l = args.l
m = args.a
file = args.g

lines_2d = []
with open(file, 'r') as f:
    for line in f:
        lines_2d.append(line.strip().split())

nodes = 0;
lin = len(lines_2d);
for i in range(lin):
  for j in range(3):
    lines_2d[i][j] = int(lines_2d[i][j]);
  if(lines_2d[i][1])>nodes:
    nodes = lines_2d[i][1];
nodes += 1;

ASAP = [[1 for i in range(2)] for j in range(nodes)]; #[time step][arranged:1 else:0]
ALAP = [[l for i in range(2)] for j in range(nodes)];
for i in range(nodes):
  ALAP[i][1] = 1;

for i in range(lin):
  ASAP[lines_2d[i][1]][0] = 0;
  ASAP[lines_2d[i][1]][1] = 0;


all_arranged = 0;
while(all_arranged == 0):
  for i in range(lin):
    if(ASAP[lines_2d[i][1]][1] == 0):
      prec_ready = 1;
      prec_max = 0;
      for j in range(lin):
        if(lines_2d[i][1] == lines_2d[j][1]):
          if(ASAP[lines_2d[j][0]][1] == 0):
            prec_ready = 0;
          else:
            if(ASAP[lines_2d[j][0]][0] > prec_max):
              prec_max = ASAP[lines_2d[j][0]][0];
      if(prec_ready == 1):
        ASAP[lines_2d[i][1]][0] = prec_max + 1;
        ASAP[lines_2d[i][1]][1] = 1;

  all_arranged = 1;
  for i in range(lin):
    if(ASAP[lines_2d[i][1]][1] == 0):
      all_arranged = 0;

for i in range(lin):
  ALAP[lines_2d[i][0]][0] = 0;
  ALAP[lines_2d[i][0]][1] = 0;

all_arranged = 0;
while(all_arranged == 0):
  for i in range(lin):
    if(ALAP[lines_2d[i][0]][1] == 0):
      prec_ready = 1;
      prec_min = l + 1;
      for j in range(lin):
        if(lines_2d[i][0] == lines_2d[j][0]):
          if(ALAP[lines_2d[j][1]][1] == 0):
            prec_ready = 0;
          else:
            if(ALAP[lines_2d[j][1]][0] < prec_min):
              prec_min = ALAP[lines_2d[j][1]][0];
      if(prec_ready == 1):
        ALAP[lines_2d[i][0]][0] = prec_min - 1;
        ALAP[lines_2d[i][0]][1] = 1;

  all_arranged = 1;
  for i in range(lin):
    if(ALAP[lines_2d[i][0]][1] == 0):
      all_arranged = 0;

STconstrains = [[0 for i in range(l)] for j in range(nodes)];
STvar = [[0 for i in range(l)] for j in range(nodes)];
for i in range(nodes):
  for j in range(l):
    STvar[i][j] = 'x'+str(i)+'_'+str(j+1);
    if(j>=ASAP[i][0]-1 and j<=ALAP[i][0]-1):
      STconstrains[i][j] = 1;

#pruning
for i in range(nodes):
  if(ASAP[i][0] == ALAP[i][0]):
    for j in range(l):
      STvar[i][j] = 0;
    STvar[i][ASAP[i][0]-1] = 1;
for i in range(nodes):
  for j in range(l):
    if(STconstrains[i][j] == 0):
      STvar[i][j] = 0;
#ol
ol=-1
for i in range(l):
  for j in range(nodes):
    if(STvar[j][l-1-i] != 0):
      ol = j;
      break;
  if(ol != -1):
    break;

PCconstrains = [[0 for i in range(l*2)] for j in range(lin)];
PCvar = [[0 for i in range(l*2)] for j in range(lin)];
for i in range(lin):
  for j in range(l):
    PCvar[i][j] = STvar[lines_2d[i][1]][j]#'x'+str(lines_2d[i][0])+'_'+str(j+1);
    PCvar[i][j+l] = STvar[lines_2d[i][0]][j] #'x'+str(lines_2d[i][1])+'_'+str(j+1);
    PCconstrains[i][j] = (j+1)*STconstrains[lines_2d[i][1]][j];
    PCconstrains[i][j+l] = (j+1)*STconstrains[lines_2d[i][0]][j];

#pruning
Yconstrains = [[0 for i in range(lin)] for j in range(l-1)];
for i in range(l-1):
  for j in range(lin):
    stz = 0;
    edz = 0;
    for k in range(l):
      if(k<=i):
        if(STvar[lines_2d[j][0]][k]!=0):
          stz = 1;
      else:
        if(STvar[lines_2d[j][1]][k]!=0):
          edz = 1;

    if(stz == 1 and edz == 1):
      Yconstrains[i][j] = 'y'+str(i+1)+'_'+str(j);

path = file+'MRLC';
f = open(path, 'w');

for i in range(nodes):
  for j in range(l):
    if(STvar[i][j]!=0 and STvar[i][j]!=1):
      f.write('var '+ STvar[i][j]+' binary >=0;\n');

f.write('var m integer >=0;\n');

for i in range(l-1):
  for j in range(lin):
    if(Yconstrains[i][j]!=0):
      f.write('var '+Yconstrains[i][j]);
      f.write(' binary >=0;\n');



f.write('minimize obj: m;\n');

ct = 1;
for i in range(nodes):
  f.write('s.t. c'+str(ct)+': ');
  ct += 1;
  for j in range(l-1):
    f.write(str(STconstrains[i][j])+'*'+str(STvar[i][j])+'+');
  f.write(str(STconstrains[i][l-1])+'*'+str(STvar[i][l-1]));
  f.write('==1;\n');

for i in range(lin):
  f.write('s.t. c'+str(ct)+': ');

  ct += 1;
  for j in range(l-1):
    f.write(str(PCconstrains[i][j])+'*'+str(PCvar[i][j])+'+');
  f.write(str(PCconstrains[i][l-1])+'*'+str(PCvar[i][l-1]));
  for j in range(l, 2*l):
    f.write('-'+str(PCconstrains[i][j])+'*'+str(PCvar[i][j]));
  f.write('-1>=0;\n');

for i in range(l-1):
  f.write('s.t. c'+str(ct)+': ');
  ct += 1;
  for j in range(lin):
    f.write(str(lines_2d[j][2])+'*'+str(Yconstrains[i][j])+'+');
  f.write('0<=m;\n');

for i in range(l-1):
  for j in range(lin):
    if(Yconstrains[i][j]!=0):
      f.write('s.t. c'+str(ct)+': ');
      ct += 1;
      for k in range(l):
        if(k<=i):
          f.write(str(STvar[lines_2d[j][0]][k])+'+');
        else:
          f.write(str(STvar[lines_2d[j][1]][k])+'+');
      f.write('0-1<='+str(Yconstrains[i][j])+';\n');

for i in range(l-1):
  for j in range(lin):
    if(Yconstrains[i][j]!=0):
      f.write('s.t. c'+str(ct)+': ');
      ct += 1;
      for k in range(l):
        if(k<=i):
          f.write(str(STvar[lines_2d[j][0]][k])+'+');
      f.write('0>='+str(Yconstrains[i][j])+';\n');

for i in range(l-1):
  for j in range(lin):
    if(Yconstrains[i][j]!=0):
      f.write('s.t. c'+str(ct)+': ');
      ct += 1;
      for k in range(l):
        if(k>i):
          f.write(str(STvar[lines_2d[j][1]][k])+'+');
      f.write('0>='+str(Yconstrains[i][j])+';\n');

f.write('solve;\n');
f.write('printf('+str(l)+');\n');
f.write('printf(", ");\n');
f.write('printf(m);\n');
f.write('end;\n');
f.close()



path = file+'MLRC';
f = open(path, 'w');

for i in range(nodes):
  for j in range(l):
    if(STvar[i][j]!=0 and STvar[i][j]!=1):
      f.write('var '+ STvar[i][j]+' binary >=0;\n');


for i in range(l-1):
  for j in range(lin):
    if(Yconstrains[i][j]!=0):
      f.write('var '+Yconstrains[i][j]);
      f.write(' binary >=0;\n');


f.write('minimize obj: 0');
for i in range(nodes):
  for j in range(l):

    f.write('+'+str(j+1)+'*'+str(STvar[i][j]));
f.write(';\n');

ct = 1;
for i in range(nodes):
  f.write('s.t. c'+str(ct)+': ');
  ct += 1;
  for j in range(l-1):
    f.write(str(STconstrains[i][j])+'*'+str(STvar[i][j])+'+');
  f.write(str(STconstrains[i][l-1])+'*'+str(STvar[i][l-1]));
  f.write('==1;\n');

for i in range(lin):
  f.write('s.t. c'+str(ct)+': ');

  ct += 1;
  for j in range(l-1):
    f.write(str(PCconstrains[i][j])+'*'+str(PCvar[i][j])+'+');
  f.write(str(PCconstrains[i][l-1])+'*'+str(PCvar[i][l-1]));
  for j in range(l, 2*l):
    f.write('-'+str(PCconstrains[i][j])+'*'+str(PCvar[i][j]));
  f.write('-1>=0;\n');

for i in range(l-1):
  f.write('s.t. c'+str(ct)+': ');
  ct += 1;
  for j in range(lin):
    f.write(str(lines_2d[j][2])+'*'+str(Yconstrains[i][j])+'+');
  f.write('0<='+str(m)+';\n');

for i in range(l-1):
  for j in range(lin):
    if(Yconstrains[i][j]!=0):
      f.write('s.t. c'+str(ct)+': ');
      ct += 1;
      for k in range(l):
        if(k<=i):
          f.write(str(STvar[lines_2d[j][0]][k])+'+');
        else:
          f.write(str(STvar[lines_2d[j][1]][k])+'+');
      f.write('0-1<='+str(Yconstrains[i][j])+';\n');

for i in range(l-1):
  for j in range(lin):
    if(Yconstrains[i][j]!=0):
      f.write('s.t. c'+str(ct)+': ');
      ct += 1;
      for k in range(l):
        if(k<=i):
          f.write(str(STvar[lines_2d[j][0]][k])+'+');
      f.write('0>='+str(Yconstrains[i][j])+';\n');

for i in range(l-1):
  for j in range(lin):
    if(Yconstrains[i][j]!=0):
      f.write('s.t. c'+str(ct)+': ');
      ct += 1;
      for k in range(l):
        if(k>i):
          f.write(str(STvar[lines_2d[j][1]][k])+'+');
      f.write('0>='+str(Yconstrains[i][j])+';\n');

f.write('solve;\n');
f.write('printf(');
for i in range(l):
  f.write(str(i+1)+'*'+str(STvar[ol][i])+'+');
f.write('0);\n');
f.write('printf(", ");\n');
f.write('printf('+str(m)+');\n');
f.write('end;\n');
f.close()

osipath = 'glpsol --math '+file+'MRLC'+'  --output '+file+'MRLCout';
os.system(osipath);
osipath = 'glpsol --math '+file+'MLRC'+'  --output '+file+'MLRCout';
os.system(osipath);

outarr = []
path = file+'MRLCout';
with open(path, 'r') as f:
    for line in f:
        outarr.append(line.strip().split())
print('MRLC: ');
for i in range(len(outarr)):
  if(len(outarr[i]) == 3):
    if(outarr[i][0] == 'Status:' and outarr[i][2]!='OPTIMAL'):
      print('FAILED ');
      break;
  if(len(outarr[i]) >= 5):
    if(outarr[i][1] == 'm'):
      print('l = '+str(l));
      print('m = '+str(outarr[i][3])+'\n')
      break;


outarr = []
path = file+'MLRCout';
with open(path, 'r') as f:
    for line in f:
        outarr.append(line.strip().split())
ava = 1;

print('MLRC: ');
for i in range(len(outarr)):
  if(len(outarr[i]) == 3):
    if(outarr[i][0] == 'Status:' and outarr[i][2]!='OPTIMAL'):
      print('FAILED ');
      ava = 0;
  if(len(outarr[i]) >= 5):
    #print(outarr[i][1]);
    for j in range(l):
      if(outarr[i][1]==STvar[ol][j]):
        #print(STvar[ol][j]);
        STvar[ol][j] = int(outarr[i][3]);

suml = 0;
for i in range(l):
    suml = suml + (i+1)*STvar[ol][i];

if(ava==1):
  print('l = '+ str(suml));
  print('m = '+str(m)+'\n')

print(ASAP);
print(ALAP);